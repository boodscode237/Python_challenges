print((lambda x: x + 1)(8))

add_one = lambda x: x + 1
print(add_one(2))

full_name = lambda first, last: f'Full name: {first.title()} {last.title()}'
print(full_name('John', 'Travolta'))

print((lambda x, y: x + y)(58, 85))

high_ord_func = lambda x, func: x + func(x)
high_ord_func(2, lambda x: x * x)

high_ord_func(2, lambda x: x + 3)


import dis

'''
The dis module exposes functions to analyze Python bytecode generated by the Python compiler
'''
add = lambda x, y: x + y
print(type(add))

print(dis.dis(add))

print(add)


print((lambda x: (x % 2 and 'odd' or 'even'))(3))

# Type Annotations

def full_name(first: str, last: str) -> str:
    return f'{first.title()} {last.title()}'

print(full_name('Vlad', 'Macron'))

# Arguments

(lambda x, y, z: x + y + z)(1, 2, 3)

(lambda x, y, z=3: x + y + z)(1, 2)

(lambda x, y, z=3: x + y + z)(1, y=2)

(lambda *args: sum(args))(1,2,3)

(lambda **kwargs: sum(kwargs.values()))(one=1, two=2, three=3)

(lambda x, *, y=0, z=0: x + y + z)(1, y=2, z=3)

def some_decorator(f):
    def wraps(*args):
        print(f"Calling function '{f.__name__}'")
        return f(args)
    return wraps

@some_decorator
def decorated_function(x):
    print(f"With argument '{x}'")
    

decorated_function("Python")
    
# Defining a decorator
def trace(f):
    def wrap(*args, **kwargs):
        print(f"[TRACE] func: {f.__name__}, args: {args}, kwargs: {kwargs}")
        return f(*args, **kwargs)

    return wrap

# Applying decorator to a function
@trace
def add_two(x):
    return x + 2

# Calling the decorated function
print(add_two(3))

# Applying decorator to a lambda
print((trace(lambda x: x ** 2))(3))

# Decorating the lambda function this way could be useful for debugging purposes,

print(list(map(trace(lambda x: x*2), range(3))))


# closures

def outer_func(x):
    y = 4
    def inner_func(z):
        print(f"x = {x}, y = {y}, z = {z}")
        return x + y + z
    return inner_func

for i in range(3):
    closure = outer_func(i)
    print(f"closure({i+5}) = {closure(i+5)}")
    

def outer_func(x):
    y = 4
    return lambda z: x + y + z

for i in range(5):
    closure = outer_func(i)
    print(f"closure({i+5}) = {closure(i+5)}")